#include <iostream>
#include <math.h>
#include <iostream>
#include <stdio.h>
using namespace std;

/********************
 * gridspace section*
 ********************/
 
struct gridspace 
{      
     std::string contents;
     gridspace *next_space; // Pointer to the next space on the board
     bool is_chute;
     bool is_ladder;
     int board_position; // Numeric position in the board
     gridspace *next_rung; // Pointer to next rung of a chute/ladder
     gridspace();
};

gridspace::gridspace() // Default constructor
{
     next_space = NULL;
     is_chute = 0;
     is_ladder = 0;
     contents = "[   ]";
     board_position = 0;
     next_rung = NULL;
}

/**********************
 * player_data section*
 **********************/

class player_data {
      public:
             void do_move();
             gridspace *get_space();
             player_data(gridspace *head, char choice);
             
      private:
              char symbol;
              gridspace *curr; // Pointer to the space the player exists in
};

player_data::player_data(gridspace *head, char choice) // Primary constructor
{
     curr = head;
     symbol = choice;
}

void player_data::do_move() // Movement function
{
     int x;
     x = curr->contents.find(symbol); // Finding the player's symbol in contents
     if (x != string::npos)
       curr->contents[x] = ' '; // Replacing with a space
 
     curr = curr->next_space; // Moving player to the next space

     x = curr->contents.find(' '); // Finding first empty space in contents
     if (x != string::npos)
       curr->contents[x] = symbol; // Replacing with symbol
     else {   
        cout << "Something weird has happened...";
        system("PAUSE");
     }
}
 
gridspace *player_data::get_space()
{
     return curr;
}
 

/*******************
 * Function section*
 *******************/

gridspace *create_board(int rows, int cols)
{
     gridspace *temp, *head;
     int i;
     head = new gridspace;
  
     temp = head;
 
     for (i = 0; i < (rows * cols); i++) {
        temp->board_position = i;
        temp->next_space = new gridspace;
        temp = temp->next_space;
     }
  
     temp->board_position = i;
  
     return head;
}    

void delete_board(gridspace *head) // Recursive cleanup function
{
     if (head->next_space != NULL)
        delete_board(head->next_space);
     delete head;
}


void print_board(gridspace *head, int rows)
{
     gridspace *temp;
     temp = head;
     while(temp->next_space != NULL) {
        cout << endl;
        do { // Traverses the list until it hits the end of the row
           cout << temp->contents;                  
           
           if (temp->next_space == NULL) // It should never hit this             
              break;
           
           temp = temp->next_space;
        } while((temp->board_position % rows) != 0);     
     }
}
int main() {
  const int row_size = 8;
  const int col_size = 8;
  gridspace *head;
  head = create_board(row_size, col_size);
  print_board(head, row_size);
  delete_board(head);
  system("PAUSE");
  return 0;
}
